category: Endpoint
commonfields:
  id: FalconQuery
  version: -1
configuration:
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: https://api.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: 'true'
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
description: The Falcon Query API (formerly known as the Falcon Firehose API)
detaileddescription: 'To get an API key please contact the crowdstrike support: support@crowdstrike.com'
display: CrowdStrike Query API
name: FalconQuery
script:
  commands:
  - arguments:
    - default: false
      description: Will limit retrieved devices to those who match the query.
      isArray: false
      name: filter
      required: false
      secret: false
    - default: false
      description: Limit results using device ids. can be multiple values seperated
        by comma.
      isArray: false
      name: ids
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using the status of the device.
      isArray: false
      name: status
      predefined:
      - Normal
      - containment_pending
      - contained
      - lift_containment_pending
      required: false
      secret: false
    - default: false
      description: Limit results using the hostname of the device.
      isArray: false
      name: hostname
      predefined:
      - ''
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using platform name of the device.
      isArray: false
      name: platfrom_name
      predefined:
      - Windows
      - Mac
      - Linux
      required: false
      secret: false
    - default: false
      description: Limit results using the site name of the device.
      isArray: false
      name: site_name
      required: false
      secret: false
    description: Searches for a device that matches the query.
    execution: false
    name: crowdstrike-search-device
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: ID of the device.
      type: String
    - contextPath: CrowdStrike.Device.LocalIP
      description: Local IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.ExternalIP
      description: External IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.Hostname
      description: Hostname of the device.
      type: String
    - contextPath: CrowdStrike.Device.OS
      description: Operating system of the device.
      type: String
    - contextPath: CrowdStrike.Device.MacAddress
      description: Mac Address of the device.
      type: String
    - contextPath: CrowdStrike.Device.FirstSeen
      description: First seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.LastSeen
      description: Last seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.PolicyType
      description: Policy types of the device.
      type: Unknown
  - arguments:
    - default: false
      description: The id of the the behavior
      isArray: false
      name: behavior_id
      required: true
      secret: false
    description: Searches and fetches the behavior that matches the query.
    execution: false
    name: crowdstrike-get-behavior
    outputs:
    - contextPath: CrowdStrike.Behavior.FileName
      description: File name in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.Scenario
      description: Scenario name in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.MD5
      description: MD5 of the IoC in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.SHA256
      description: SHA256 of the IoC in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.IOCType
      description: Type of the indicator of compromise.
      type: String
    - contextPath: CrowdStrike.Behavior.IOCValue
      description: Value of the indicator of compromise.
      type: String
    - contextPath: CrowdStrike.Behavior.CommandLine
      description: Command line executed in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.UserName
      description: User name who's related to the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.SensorID
      description: Sensor ID related to the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.ParentProcessID
      description: ID of the parent process.
      type: String
    - contextPath: CrowdStrike.Behavior.ProcessID
      description: Process ID the behavior.
      type: String
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    # TODO: ADD crowdstrike-get-behavior command

    import json
    import requests
    import base64
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else \
        demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('insecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'device.hostname': 'System',
        'device.cid': 'CustomerIDString',
        'hostinfo.domain': 'MachineDomain',
        'detection_id': 'DetectionID',
        'created_timestamp': 'ProcessStartTime'
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'Scenario',
        'md5': 'MD5',
        'sha256': 'SHA256',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName'
    }

    SEARCH_IOC_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'policy': 'Policy',
        'source': 'Source',
        'share_level': 'ShareLevel',
        'expiration_timestamp': 'Expiration',
        'description': 'Description',
        'created_timestamp': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_timestamp': 'ModifiedTime',
        'modified_by': 'ModifiedBy'
    }

    SEARCH_DEVICE_KEY_MAP = {
        'device_id': 'ID',
        'external_ip': 'ExternalIP',
        'local_ip': 'LocalIP',
        'hostname': 'Hostname',
        'os_version': 'OS',
        'mac_address': 'MacAddress',
        'first_seen': 'FirstSeen',
        'last_seen': 'LastSeen'
    }  # TODO: Add PolicyType via a function - key is policies

    ''' SPLIT KEY DICTIONARY '''

    #   Pattern: {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params=None, data=None, headers=HEADERS, safe=False):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        url = SERVER + url_suffix
        demisto.info("\n\n####SENDING URL: {}\n".format(url))
        res = requests.request(
            method,
            url,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=headers,
        )
        # Handle error responses gracefully
        demisto.info('\n\n#### Request: {}\n'.format(str(data)))
        if res.status_code not in {200, 201}:
            if safe:
                return None
            return_error('Error in API call [%d] - %s' % (res.status_code, res.reason))
        return res.json()


    def create_entry_object(contents='', ec=None, hr=''):
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }


    def detection_to_incident(detection):
        incident = {
            'name': 'Detection ID: ' + convert_to_str(detection.get('detection_id')),
            'occurred': convert_to_str(detection.get('first_behavior')),
            'rawJSON': json.dumps(detection),
            'severity': severity_string_to_int(detection.get('max_severity_displayname'))
        }
        return incident


    def severity_string_to_int(severity):
        if severity in ('Critical', 'High'):
            return 3
        elif severity in ('Medium', 'Low'):
            return 2
        return 0


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
        Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
        """
        new_dict = {}
        for k in old_dict.keys():
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
        Extracts new values out of old_dict using a json structure of:
        {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except:
                LOG('Error with: {}'.format(trans_dict))
        return new_dict


    def convert_to_str(obj):
        """
        Converts an obj to an str
        """
        if isinstance(obj, unicode):
            return obj.encode('utf-8')
        try:
            return str(obj)
        except:
            return obj


    ''' COMMAND SPECIFIC FUNCTIONS '''


    def get_token():
        body = {
            'client_id': USERNAME,
            'client_secret': PASSWORD
        }
        headers = {
            'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
        }
        token_res = http_request('POST', '/oauth2/token', data=body, headers=headers, safe=True)
        if not token_res:
            err_msg = 'Authorization Error: User has no authorization to create a token.'
            if demisto.command() != 'fetch-incidents':
                return_error(err_msg)
            raise Exception(err_msg)

        return token_res.get('access_token')


    def get_detections(last_behavior_time=None, behavior_id=None):
        endpoint_url = '/detects/queries/detects/v1'
        params = {
            'sort': 'first_behavior.asc'
        }
        if behavior_id:
            params['filter'] = 'behaviors.behavior_id=\'{0}\''.format(behavior_id)
        elif last_behavior_time:
            params['filter'] = "first_behavior:>'{0}'".format(last_behavior_time)

        headers = {'Authorization': 'Bearer ' + TOKEN}
        response = http_request('GET', endpoint_url, params, headers=headers)
        return response


    def get_detections_entities(detections_ids):
        ids_json = {'ids': detections_ids}
        if detections_ids:
            headers = {
                'Authorization': 'Bearer ' + TOKEN,
                'Content-Type': 'application/json'
            }
            response = http_request(
                'POST',
                '/detects/entities/summaries/GET/v1',
                data=json.dumps(ids_json),
                headers=headers
            )
            return response
        return detections_ids


    def create_ioc():
        args = demisto.args()
        input_args = {}
        try:
            input_args['type'] = args['ioc_type']
            input_args['value'] = args['ioc_value']
            input_args['policy'] = args['policy']
        except KeyError, e:
            arg = e.args[0]
            return_error("Command Error: Please provide mandatory argument: {0}".format(arg))
        input_args['expiration_days'] = args.get('expiration_days')
        input_args['source'] = args.get('source')
        input_args['description'] = args.get('description')
        payload = {k: convert_to_str(v) for k, v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('POST', '/indicators/entities/iocs/v1', params=payload, headers=headers)


    def search_iocs():
        args = demisto.args()
        ids = args.get('ids')
        if not ids:
            search_args = {
                'types': convert_to_str(args.get('ioc_types', '')).split(','),
                'values': convert_to_str(args.get('ioc_values', '')).split(','),
                'policies': convert_to_str(args.get('policy', '')),
                'sources': convert_to_str(args.get('sources', '')).split(','),
                'from.expiration_timestamp': convert_to_str(args.get('expiration_from', '')),
                'to.expiration_timestamp': convert_to_str(args.get('expiration_to', '')),
                'limit': convert_to_str(args.get('limit', 50))
            }
            payload = {}
            for k, arg in search_args.iteritems():
                if type(arg) is list:
                    if arg[0]:
                        payload[k] = arg
                elif arg:
                    payload[k] = arg
            ids = http_request('GET', '/indicators/queries/iocs/v1', payload).get('resources')
            if not ids:
                return None
        else:
            ids = convert_to_str(ids)
        payload = {
            'ids': ids
        }
        return http_request('GET', '/indicators/entities/iocs/v1', params=payload)


    def enrich_ioc_dict_with_ids(ioc_dict):
        for ioc in ioc_dict:
            ioc['ID'] = '{0}:{1}'.format(ioc.get('Type'), ioc.get('Value'))


    def delete_ioc():
        ids = convert_to_str(demisto.args().get('ids'))
        payload = {
            'ids': ids
        }
        return http_request('DELETE', '/indicators/entities/iocs/v1', payload)


    def update_iocs():
        args = demisto.args()
        input_args = {
            'ids': args.get('ids'),
            'policy': args.get('policy', ''),
            'expiration_days': args.get('expiration_days', ''),
            'source': args.get('source'),
            'description': args.get('description')
        }
        payload = {k: convert_to_str(v) for k, v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('PATCH', '/indicators/entities/iocs/v1', params=payload, headers=headers)


    def search_device():
        """
        Searches for devices using the argument provided by the command execution. Returns empty result of no device was found.
        """
        args = demisto.args()
        input_arg_dict = {
            'device_id': convert_to_str(args.get('ids', '')).split(','),
            'status': convert_to_str(args.get('status', '')).split(','),
            'hostname': convert_to_str(args.get('hostname', '')).split(','),
            'platform_name': convert_to_str(args.get('platform_name', '')).split(','),
            'site_name': convert_to_str(args.get('site_name', '')).split(',')
        }
        url_filter = ''.format(convert_to_str(args.get('filter', '')))
        for k, arg in input_arg_dict.iteritems():
            if arg:
                if type(arg) is list:
                    arg_filter = ''
                    for arg_elem in arg:
                        if arg_elem:
                            arg_filter = "{0}:'{1}'".format('{0},{1}'.format(arg_filter, k) if arg_filter else k, arg_elem)
                    if arg_filter:
                        url_filter = "{0}{1}".format(url_filter + '+' if url_filter else '', arg_filter)
                else:
                    # All args should be a list. this is a fallback
                    url_filter = "{0}+{1}:'{2}'".format(url_filter, k, arg)
        headers = {
            'Authorization': 'Bearer ' + TOKEN,
            'Content-Type': 'application/json'
        }
        raw_res = http_request('GET', '/devices/queries/devices/v1', params={'filter': url_filter}, headers=headers)
        device_ids = raw_res.get('resources')
        if not device_ids:
            return None
        return http_request('GET', '/devices/entities/devices/v1', params={'ids': device_ids}, headers=headers)


    def behavior_to_entry_context(behavior):
        raw_entry = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_entry.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        return raw_entry


    ''' COMMANDS FUNCTIONS '''


    def fetch_incidents():
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_behavior_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        last_fetch_timestamp = date_to_timestamp(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        detections_ids = demisto.get(get_detections(last_behavior_time=last_fetch), 'resources')
        raw_res = get_detections_entities(detections_ids)
        if "resources" in raw_res:
            for detection in demisto.get(raw_res, "resources"):
                incident = detection_to_incident(detection)
                incident_date = incident['occurred']
                incident_date_timestamp = date_to_timestamp(incident_date, date_format='%Y-%m-%dT%H:%M:%SZ')
                # Update last run and add incident if the incident is newer than last fetch
                if incident_date_timestamp > last_fetch_timestamp:
                    last_fetch = incident_date
                incidents.append(incident)

        demisto.setLastRun({'first_behavior_time': last_fetch})
        return incidents


    def create_ioc_command():
        raw_res = create_ioc()
        return create_entry_object(contents=raw_res, hr="Custom IoC was created successfully.")


    def search_iocs_command():
        raw_res = search_iocs()
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, SEARCH_IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IoC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicators of Compromise', ec))


    def delete_iocs_command():
        raw_res = delete_ioc()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully deleted.".format(ids))


    def update_iocs_command():
        raw_res = update_iocs()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully updated.".format(ids))


    def search_device_command():
        raw_res = search_device()
        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')
        ec = [get_trasnformed_dict(device, SEARCH_DEVICE_KEY_MAP) for device in devices]
        hr = tableToMarkdown('Devices', ec,
                             headers=['ID', 'Hostname', 'OS', 'MacAddress', 'LocalIP', 'ExternalIP', 'FirstSeen',
                                      'LastSeen'])
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.Device(val.ID === obj.ID)': ec}, hr=hr)


    def get_behavior_command():
        behavior_id = demisto.args().get('behavior_id')
        detections_ids = demisto.get(get_detections(behavior_id=behavior_id), 'resources')
        raw_res = get_detections_entities(detections_ids)
        ec = []
        if "resources" in raw_res:
            for resource in demisto.get(raw_res, "resources"):
                for behavior in demisto.get(resource, 'behaviors'):
                    ec.append(behavior_to_entry_context(behavior))
        hr = tableToMarkdown('Behavior ID: {}'.format(behavior_id), ec)
        return create_entry_object(raw_res, ec, hr)


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))

    TOKEN = get_token()

    if demisto.command() == 'test-module':
        # if not set properly will fail when trying to get_token, so if reached here then test passed
        demisto.results('ok')
    elif demisto.command() == 'fetch-incidents':
        demisto.incidents(fetch_incidents())
    elif demisto.command() == 'crowdstrike-search-device':
        demisto.results(search_device_command())
    elif demisto.command() == 'crowdstrike-get-behavior':
        demisto.results(get_behavior_command())
  type: python
image: data:image/png;base64,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
